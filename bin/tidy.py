#! python

# Opens pdb.toml and converts it to a Python dictionary
# Then it processes each top level entry, and extracts the solvent condition.
# It shows a tqdl progress bar during processing
# There is a short option that only processes the first 1000 top level keys.
# These are not consistently written, so we have to try varios methods.
# It then writes a new training.toml file with the solvent conditions and the original sequence.

import toml
import numpy as np
import tqdm
import sys
import gzip
import re
import datetime

class PdbParseException (Exception):
    pass

# Open the pdb.toml file
with gzip.open("pdb.toml.gz", "rt") as f:
    print("Loading data...")
    pdb = toml.load(f)

err = open("tidy.err", "wt")

# Sequence lenght for some stats
seqlen = []
records_processed = 0


# Open the training.toml file
with open("training.toml", "wt") as f:
    # Write the header
    f.write("# This file is generated by tidy.py\n")
    f.write("# Generated on {date}\n".format(date=datetime.datetime.now()))
    f.write("# It contains the sequence and solvent condition for each PDB entry that passes muster.\n")
    # The set of all hash keys
    key_count = {}
    # Process each top level key
    for key in tqdm.tqdm(pdb.keys()):
        try: 
            # Get the value
            value = pdb[key]
            l = len(value["sequence"])
            seqlen.append(l)
            if l > 7000:
                raise PdbParseException(f"ERROR 53: [{key}] Sequence length {l} is too long".format(key=key, l=l))
            if l < 15:
                raise PdbParseException(f"ERROR 54: [{key}] Sequence length {l} is too short".format(key=key, l=l))
            # If sequence contains whitespace, something is wrong
            if re.search(r"\s", value["sequence"]):
                raise PdbParseException(f"ERROR 56: [{key}] Sequence contains whitespace".format(key=key))

            solvent = None
            # Try to get the solvent condition
            crco = value.get("crystal_conditions")
            values = {} 

            # Case insensitive match with regexp: "Conditions: .... PH: 7.0"
            if crco is not None:
                # This is all a big hack, and needs to be moved into a library with unit tests. 

                # Extract the PH from PH 7.00, or pH 7.00
                m = re.search(r"PH:?\s+([0-9.]+)", crco, re.IGNORECASE)
                # check if it is a float, and store in the ph variable
                if m is not None:
                    # remove trailing period.
                    try:
                        m = re.sub(r"\.$", "", m.group(1))
                        ph = float(m)
                        values["ph"] = ph
                    except ValueError:
                        raise PdbParseException(f"ERROR 55: [{key}] Could not parse PH from crystal conditions: {crco}".format(key=key, crco=crco))

                    #raise PdbParseException(f"ERROR 51: [{key}] Could not parse PH from crystal conditions: {crco}".format(key=key, crco=crco))
                # Extract the matthews coefficient from "38.45 MATTHEWS COEFFICIENT"
                m = re.search(r"([0-9.]+)\s+MATTHEWS COEFFICIENT", crco, re.IGNORECASE)
                # check that we have it, and store in the matthews variable
                if m is not None:
                    matthews = float(m.group(1))
                    values["matthews"] = matthews
                else:
                    values["no_matthews"] = 1
                    #raise PdbParseException(f"ERROR 52: [{key}] Could not parse Matthews coefficient from crystal conditions: {crco}".format(key=key, crco=crco))
                
                # extract the peg number of the form PEG 1000
                m = re.search(r"PEG\s+([0-9]+)", crco, re.IGNORECASE)
                if m is not None:
                    peg = int(m.group(1))
                    values["peg_length"] = peg

                # extract the PEG percentage and length from 26% PEG 6000
                m = re.search(r"([0-9]+)%\s+PEG\s+([0-9]+)", crco, re.IGNORECASE)
                if m is not None:
                    peg = int(m.group(2))
                    values["peg_length"] = peg
                    values["peg_percent"] = int(m.group(1))
                
                # extract the names and the numbers in the format of "CRYSTALLIZATION CONDITIONS: 15MM MES, 0.5M NACL, 20MM BME"
                m = re.search(r"CRYSTALLIZATION CONDITIONS: (.*)", crco, re.IGNORECASE)
                if m is not None:
                    # split on comma
                    for c in m.group(1).split(","):
                        # These segments can be of the form 
                        # "15MM MES" 
                        # "0.5M NACL"
                        # "20MM BME"
                        try:
                            # get the number and name for "15.3MM MES"
                            doublette = re.search(r"([0-9.]+)\s+MM\s+([A-Z ]+)", c, re.IGNORECASE)
                            if doublette is not None:
                                number = float(doublette.group(1))
                                name = doublette.group(2)
                                values[f"{name}_mM"] = number

                            # get the number and name for "15.3M MES"
                            doublette = re.search(r"([0-9.]+)\s+M\s+([A-Z ]+)", c, re.IGNORECASE)
                            if doublette is not None:
                                number = float(doublette.group(1))
                                name = doublette.group(2)
                                values[f"{name}_mM"] = number*1000

                            # "0.5 M NACL"
                            doublette = re.search(r"([0-9.]+)\s+M\s+([A-Z ]+)", c, re.IGNORECASE)
                            if doublette is not None:
                                number = float(doublette.group(1))
                                name = doublette.group(2)
                                values[f"{name}_mM"] = number*1000
                            # "0.5 MM NACL"
                            doublette = re.search(r"([0-9.]+)\s+MM\s+([A-Z ]+)", c, re.IGNORECASE)
                            if doublette is not None:
                                number = float(doublette.group(1))
                                name = doublette.group(2)
                                values[f"{name}_mM"] = number
                        except ValueError:
                            raise PdbParseException(f"ERROR 57: [{key}] Could not parse crystallization conditions (doublette error): {crco}".format(key=key, crco=crco))

                # Get number for "VM (ANGSTROMS**3/DA): 2.70"
                m = re.search(r"VM \(ANGSTROMS\*\*3/DA\):\s+([0-9.]+)", crco, re.IGNORECASE)
                if m is not None:
                    vm = float(m.group(1))
                    values["vm_A_pwr_DA"] = vm

            # if there are fewer than 4 interesting things in the values hash, skip the writing and throw an error
            if len(values) < 4:
                #raise PdbParseException(f"ERROR 58: [{key}] Is not interesting, less than 4 values found: {crco}".format(key=key, crco=crco))
                pass
            solvent = pdb[key]["crystal_conditions"]

            sequence = pdb[key]["sequence"]
            f.write(f"[{key}]\n")
            f.write(f'sequence="{sequence}"\n')
            # make sure all spaces in the key of the values hash are replaced by underscore
            values = {k.replace(" ", "_"): v for k, v in values.items()}
            # make sure all keys are lowercase
            values = {k.lower(): v for k, v in values.items()}

            # make the toml string for the values hash
            values_str = ", ".join([f"{k}={v}" for k, v in values.items()])
            f.write(f"values = {{{values_str}}}\n")
            # increment key count
            for k in values.keys():
                if k not in key_count:
                    key_count[k] = 0
                key_count[k] += 1
            records_processed += 1



        except PdbParseException as e:
            print(e)
            err.write(str(e) + "\n")
            continue
    f.write("\n")
    f.write("[metadata]\n")

    # count the key counts that are greater than 10 and collect them with their count in sig_key_count
    key_count_gt_10 = 0
    sig_key_count = {}
    for k, v in key_count.items():
        if v > 10:
            key_count_gt_10 += 1
            sig_key_count[k] = v
    f.write(f"sig_key_count = {{{', '.join([f'{k}={v}' for k, v in sig_key_count.items()])}}}\n")
    # write the key count hash
    f.write(f"key_count = {{{', '.join([f'{k}={v}' for k, v in key_count.items()])}}}\n")

    # write sequence length mean, median and stddev
    f.write(f"seqlen_mean = {np.mean(seqlen)}\n")
    f.write(f"seqlen_median = {np.median(seqlen)}\n")
    f.write(f"seqlen_stddev = {np.std(seqlen)}\n")
    f.write(f"record_count = {records_processed}\n")

    f.write(f"sig_key_count_gt_10 = {key_count_gt_10}\n")


